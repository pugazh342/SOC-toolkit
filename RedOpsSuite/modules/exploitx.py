# RedOpsSuite/modules/exploitx.py
import subprocess
import json
import yaml
import time
import os
import logging
from datetime import datetime

# --- Setup basic logging for standalone execution ---
logger = logging.getLogger(__name__)
logger.propagate = False
logger.setLevel(logging.DEBUG)
if not logger.handlers:
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)
# --- End logging setup ---

class ExploitX:
    """
    A basic Exploitation Launcher for RedOpsSuite.
    Manages exploit definitions, configures parameters, and launches exploits
    (built-in PoCs or external tools like Metasploit).
    """

    def __init__(self, exploits_db_path="config/exploits.yaml"):
        """
        Initializes the ExploitX module.

        Args:
            exploits_db_path (str): Path to the local exploits database file (YAML/JSON).
                                    Default is 'config/exploits.yaml'.
        """
        self.exploits_db_path = exploits_db_path
        self.exploits_db = self._load_exploits_db()
        self.results = [] # Store results of exploit attempts
        logger.info(f"ExploitX module initialized with DB: {self.exploits_db_path}")

    def _load_exploits_db(self):
        """
        Loads the exploits database from a YAML or JSON file.

        Returns:
            dict: A dictionary representing the loaded exploits database.
        """
        db = {}
        if os.path.exists(self.exploits_db_path):
            try:
                with open(self.exploits_db_path, 'r') as f:
                    if self.exploits_db_path.endswith('.yaml') or self.exploits_db_path.endswith('.yml'):
                        db = yaml.safe_load(f) or {}
                    elif self.exploits_db_path.endswith('.json'):
                        db = json.load(f) or {}
                    else:
                        logger.error(f"ExploitX: Unsupported database file format for {self.exploits_db_path}. Use .yaml/.yml or .json")
                        return {}
                logger.info(f"ExploitX: Loaded {len(db.get('exploits', []))} exploits from {self.exploits_db_path}")
            except (yaml.YAMLError, json.JSONDecodeError) as e:
                logger.error(f"ExploitX: Error parsing exploits database {self.exploits_db_path}: {e}")
            except Exception as e:
                logger.error(f"ExploitX: Unexpected error loading database {self.exploits_db_path}: {e}")
        else:
            logger.warning(f"ExploitX: Exploits database file not found at {self.exploits_db_path}. Initializing empty DB.")
            # Create a basic example DB structure
            example_db = {
                "metadata": {
                    "version": "1.0",
                    "last_updated": datetime.now().isoformat()
                },
                "exploits": [
                    {
                        "id": "POC-001",
                        "name": "Example HTTP PoC",
                        "description": "A basic example PoC for an HTTP service.",
                        "type": "poc",
                        "target": {
                            "service": "http",
                            "cve": "N/A"
                        },
                        "parameters": {
                            "target_host": {"type": "string", "required": True, "description": "Target hostname or IP"},
                            "target_port": {"type": "integer", "required": False, "default": 80, "description": "Target port"}
                        },
                        "execution": {
                            "handler": "builtin_poc_example_http" # Name of internal method
                        }
                    },
                    {
                        "id": "MSF-EXPLOIT-123",
                        "name": "Metasploit Example Exploit",
                        "description": "Launches a Metasploit exploit module.",
                        "type": "metasploit",
                        "target": {
                            "service": "ssh",
                            "cve": "CVE-XXXX-YYYY"
                        },
                        "parameters": {
                            "target_host": {"type": "string", "required": True},
                            "target_port": {"type": "integer", "required": False, "default": 22},
                            "username": {"type": "string", "required": False, "default": "root"},
                            "password": {"type": "string", "required": False, "default": "password"}
                        },
                        "execution": {
                            "msf_module": "exploit/linux/ssh/example_exploit",
                            "msf_options": "RHOSTS {target_host} RPORT {target_port} USERNAME {username} PASSWORD {password}"
                        }
                    }
                    # Add more exploits to the database file
                ]
            }
            self._save_exploits_db(example_db) # Save the example DB
            db = example_db
        return db

    def _save_exploits_db(self, db_dict):
        """
        Saves the exploits database dictionary to the file.

        Args:
            db_dict (dict): The exploits database dictionary to save.
        """
        try:
            os.makedirs(os.path.dirname(self.exploits_db_path), exist_ok=True)
            with open(self.exploits_db_path, 'w') as f:
                if self.exploits_db_path.endswith('.yaml') or self.exploits_db_path.endswith('.yml'):
                    yaml.dump(db_dict, f, default_flow_style=False, sort_keys=False)
                elif self.exploits_db_path.endswith('.json'):
                    json.dump(db_dict, f, indent=4)
            logger.info(f"ExploitX: Saved exploits database to {self.exploits_db_path}")
        except Exception as e:
            logger.error(f"ExploitX: Error saving exploits database to {self.exploits_db_path}: {e}")

    def list_exploits(self, filter_by=None):
        """
        Lists available exploits, optionally filtered.

        Args:
            filter_by (dict, optional): Filter criteria (e.g., {'target': {'service': 'http'}}).

        Returns:
            list: A list of exploit dictionaries matching the filter.
        """
        all_exploits = self.exploits_db.get('exploits', [])
        if not filter_by:
            logger.debug(f"ExploitX: Listed all {len(all_exploits)} exploits.")
            return all_exploits

        filtered_exploits = []
        # Basic filtering logic (supports filtering by top-level keys in exploit dict)
        for exploit in all_exploits:
            match = True
            for key, value in filter_by.items():
                if isinstance(value, dict):
                    # Handle nested filtering (e.g., filter_by={'target': {'service': 'http'}})
                    exploit_value = exploit.get(key, {})
                    if not isinstance(exploit_value, dict):
                        match = False
                        break
                    for sub_key, sub_value in value.items():
                        if exploit_value.get(sub_key) != sub_value:
                            match = False
                            break
                else:
                    # Handle simple top-level filtering
                    if exploit.get(key) != value:
                        match = False
                        break
            if match:
                filtered_exploits.append(exploit)

        logger.debug(f"ExploitX: Listed {len(filtered_exploits)} exploits after filtering by {filter_by}.")
        return filtered_exploits

    def get_exploit_by_id(self, exploit_id):
        """
        Retrieves a specific exploit definition by its ID.

        Args:
            exploit_id (str): The unique ID of the exploit.

        Returns:
            dict or None: The exploit dictionary if found, otherwise None.
        """
        for exploit in self.exploits_db.get('exploits', []):
            if exploit.get('id') == exploit_id:
                logger.debug(f"ExploitX: Found exploit by ID '{exploit_id}'.")
                return exploit
        logger.warning(f"ExploitX: Exploit with ID '{exploit_id}' not found.")
        return None

    def _builtin_poc_example_http(self, config):
        """
        A built-in example PoC for an HTTP service.
        This is a placeholder and should be replaced with real exploit logic.

        Args:
            config (dict): Configuration dictionary with exploit parameters.

        Returns:
            dict: A dictionary containing the result of the PoC execution.
        """
        result = {
            "exploit_id": "POC-001",
            "target": f"{config.get('target_host')}:{config.get('target_port', 80)}",
            "type": "poc",
            "status": "running",
            "output": "",
            "timestamp": datetime.now().isoformat(),
            "success": False,
            "error": None
        }
        try:
            target_host = config.get('target_host')
            target_port = config.get('target_port', 80)
            if not target_host:
                raise ValueError("Missing required parameter: target_host")

            # --- Simulate PoC Logic ---
            # In a real PoC, this would involve sending specific HTTP requests,
            # analyzing responses, etc.
            logger.info(f"ExploitX (PoC): Launching example HTTP PoC against {target_host}:{target_port}...")
            result['output'] += f"[+] Connecting to {target_host}:{target_port}\n"
            # Simulate delay
            time.sleep(2)
            result['output'] += f"[+] Sending malicious payload...\n"
            time.sleep(1)
            # Simulate a potential outcome
            # Let's randomly decide success/failure for demo
            import random
            if random.choice([True, False]):
                result['output'] += f"[!] Potential vulnerability detected!\n"
                result['output'] += f"[+] Retrieved sensitive data: example_data.txt\n"
                result['success'] = True
                result['status'] = "completed"
                logger.info(f"ExploitX (PoC): Example HTTP PoC succeeded against {target_host}:{target_port}.")
            else:
                result['output'] += f"[-] Exploit failed or no vulnerability found.\n"
                result['status'] = "completed"
                logger.info(f"ExploitX (PoC): Example HTTP PoC failed against {target_host}:{target_port}.")

        except Exception as e:
            result['status'] = "error"
            result['error'] = f"PoC execution failed: {str(e)}"
            result['output'] += f"[!] Error: {str(e)}\n"
            logger.error(f"ExploitX (PoC): Error executing example HTTP PoC: {e}", exc_info=True)

        return result

    def _launch_metasploit(self, exploit_definition, config):
        """
        Launches a Metasploit exploit module using msfconsole.

        Args:
            exploit_definition (dict): The exploit definition dictionary.
            config (dict): Configuration dictionary with exploit parameters.

        Returns:
            dict: A dictionary containing the result of the Metasploit execution.
        """
        result = {
            "exploit_id": exploit_definition.get('id'),
            "target": f"{config.get('target_host')}:{config.get('target_port')}",
            "type": "metasploit",
            "status": "running",
            "output": "",
            "timestamp": datetime.now().isoformat(),
            "success": False,
            "error": None
        }
        try:
            msf_module = exploit_definition['execution'].get('msf_module')
            msf_options_template = exploit_definition['execution'].get('msf_options')

            if not msf_module or not msf_options_template:
                raise ValueError("Missing Metasploit module or options in exploit definition.")

            # Substitute parameters into the MSF options string
            msf_options = msf_options_template.format(**config)

            # Construct the msfconsole command
            # Using -x to execute commands and -q for quiet mode
            cmd = [
                'msfconsole', '-q', '-x',
                f"use {msf_module}; set {msf_options}; run; exit;"
            ]
            # Alternative: Use msfconsole -r resource_script.rc
            # Where resource_script.rc contains the commands

            logger.info(f"ExploitX (MSF): Launching Metasploit exploit '{msf_module}' with options: {msf_options}")
            result['output'] += f"[+] Launching Metasploit: {' '.join(cmd[:3])} ...\n" # Don't log full command with passwords
            result['output'] += f"[+] Module: {msf_module}\n"
            result['output'] += f"[+] Options: {msf_options.split()[0]} ... (truncated)\n" # Truncate options

            # --- Execute the Command ---
            # Important: This executes system commands. Ensure inputs are sanitized.
            # subprocess.run is generally safer than shell=True, but command construction is still crucial.
            # Consider timeouts and capturing output securely.
            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT, # Capture stderr with stdout
                text=True,
                # shell=True is dangerous, avoid if possible. The list form of cmd should work.
                # cwd='/path/to/metasploit' # If msfconsole is not in PATH
            )

            # Wait for completion with a timeout (important!)
            # Communicate waits for process to finish
            stdout, _ = proc.communicate(timeout=300) # 5 minute timeout

            result['output'] += stdout
            result['status'] = "completed"

            # Check return code
            if proc.returncode == 0:
                result['success'] = True
                logger.info(f"ExploitX (MSF): Metasploit exploit '{msf_module}' completed (check output for success).")
            else:
                logger.warning(f"ExploitX (MSF): Metasploit exploit '{msf_module}' finished with non-zero exit code {proc.returncode}.")

        except subprocess.TimeoutExpired:
            result['status'] = "error"
            result['error'] = "Metasploit execution timed out."
            result['output'] += f"[!] Error: {result['error']}\n"
            logger.error(f"ExploitX (MSF): Execution of '{exploit_definition.get('id')}' timed out.")
            # Attempt to kill the process if it's still running
            try:
                proc.kill()
            except:
                pass
        except FileNotFoundError:
            result['status'] = "error"
            result['error'] = "msfconsole not found. Is Metasploit Framework installed and in PATH?"
            result['output'] += f"[!] Error: {result['error']}\n"
            logger.error(f"ExploitX (MSF): {result['error']}")
        except Exception as e:
            result['status'] = "error"
            result['error'] = f"Error launching Metasploit: {str(e)}"
            result['output'] += f"[!] Error: {str(e)}\n"
            logger.error(f"ExploitX (MSF): Error launching exploit '{exploit_definition.get('id')}': {e}", exc_info=True)

        return result

    def launch_exploit(self, exploit_id, parameters):
        """
        Launches a specific exploit with the given parameters.

        Args:
            exploit_id (str): The ID of the exploit to launch.
            parameters (dict): A dictionary of parameters to pass to the exploit.

        Returns:
            dict: A dictionary containing the result of the exploit execution.
        """
        logger.info(f"ExploitX: Attempting to launch exploit '{exploit_id}' with parameters {parameters}")
        exploit_def = self.get_exploit_by_id(exploit_id)
        if not exploit_def:
            error_result = {
                "exploit_id": exploit_id,
                "target": "N/A",
                "type": "unknown",
                "status": "error",
                "output": "",
                "timestamp": datetime.now().isoformat(),
                "success": False,
                "error": f"Exploit ID '{exploit_id}' not found."
            }
            logger.error(error_result['error'])
            self.results.append(error_result)
            return error_result

        # Validate required parameters
        exploit_params = exploit_def.get('parameters', {})
        for param_name, param_info in exploit_params.items():
            if param_info.get('required', False) and param_name not in parameters:
                # Use default if available and not provided
                if 'default' in param_info:
                    parameters[param_name] = param_info['default']
                    logger.debug(f"ExploitX: Using default value for optional parameter '{param_name}': {param_info['default']}")
                else:
                    error_result = {
                        "exploit_id": exploit_id,
                        "target": "N/A",
                        "type": exploit_def.get('type'),
                        "status": "error",
                        "output": "",
                        "timestamp": datetime.now().isoformat(),
                        "success": False,
                        "error": f"Missing required parameter: {param_name}"
                    }
                    logger.error(error_result['error'])
                    self.results.append(error_result)
                    return error_result
            elif param_name not in parameters and 'default' in param_info:
                 # Set default for non-required params if not provided
                 parameters[param_name] = param_info['default']
                 logger.debug(f"ExploitX: Setting default value for parameter '{param_name}': {param_info['default']}")

        exploit_type = exploit_def.get('type')
        execution_handler = exploit_def.get('execution', {}).get('handler')
        result = {
            "exploit_id": exploit_id,
            "target": "N/A", # Will be filled by the handler
            "type": exploit_type,
            "status": "pending",
            "output": "",
            "timestamp": datetime.now().isoformat(),
            "success": False,
            "error": None
        }

        try:
            if exploit_type == 'poc' and execution_handler:
                # Dispatch to internal PoC handler
                handler_method = getattr(self, f"_{execution_handler}", None)
                if handler_method and callable(handler_method):
                    logger.info(f"ExploitX: Dispatching to internal PoC handler '{execution_handler}'.")
                    result = handler_method(parameters)
                else:
                    result['status'] = "error"
                    result['error'] = f"Internal PoC handler '{execution_handler}' not found or not callable."
                    logger.error(result['error'])

            elif exploit_type == 'metasploit':
                # Launch via Metasploit
                logger.info("ExploitX: Dispatching to Metasploit launcher.")
                result = self._launch_metasploit(exploit_def, parameters)

            else:
                result['status'] = "error"
                result['error'] = f"Unsupported or unspecified exploit type/handler: {exploit_type}/{execution_handler}"
                logger.error(result['error'])

        except Exception as e:
            result['status'] = "error"
            result['error'] = f"Unexpected error during exploit launch: {str(e)}"
            result['output'] += f"[!] Unexpected Error: {str(e)}\n"
            logger.error(f"ExploitX: Unexpected error launching exploit '{exploit_id}': {e}", exc_info=True)

        self.results.append(result)
        logger.info(f"ExploitX: Exploit '{exploit_id}' execution finished. Success: {result.get('success')}. Status: {result.get('status')}.")
        return result

    def get_results(self):
        """Returns the results from the last exploit runs."""
        return self.results

    def clear_results(self):
        """Clears the stored results."""
        self.results = []

    def add_exploit(self, exploit_definition):
        """
        Adds a new exploit definition to the database.

        Args:
            exploit_definition (dict): A dictionary defining the exploit.
        """
        if 'exploits' not in self.exploits_db:
            self.exploits_db['exploits'] = []
        self.exploits_db['exploits'].append(exploit_definition)
        self.exploits_db['metadata']['last_updated'] = datetime.now().isoformat()
        self._save_exploits_db(self.exploits_db)
        logger.info(f"ExploitX: Added new exploit '{exploit_definition.get('id', 'N/A')}' to database.")

    def remove_exploit(self, exploit_id):
        """
        Removes an exploit definition from the database by ID.

        Args:
            exploit_id (str): The ID of the exploit to remove.
        """
        if 'exploits' in self.exploits_db:
            original_count = len(self.exploits_db['exploits'])
            self.exploits_db['exploits'] = [e for e in self.exploits_db['exploits'] if e.get('id') != exploit_id]
            new_count = len(self.exploits_db['exploits'])
            if new_count < original_count:
                self.exploits_db['metadata']['last_updated'] = datetime.now().isoformat()
                self._save_exploits_db(self.exploits_db)
                logger.info(f"ExploitX: Removed exploit '{exploit_id}' from database.")
            else:
                logger.info(f"ExploitX: Exploit '{exploit_id}' not found in database for removal.")


# Example usage (if run directly)
if __name__ == '__main__':
    # Example: Demonstrate listing and launching an exploit
    exploitx = ExploitX(exploits_db_path="config/exploits_demo.yaml") # Use a demo DB path

    print("--- ExploitX Basic Demo ---")
    print(f"Using database: {exploitx.exploits_db_path}")
    print("-" * 30)

    # 1. List available exploits
    print("\n1. Listing Available Exploits:")
    all_exploits = exploitx.list_exploits()
    for exploit in all_exploits:
        print(f" - ID: {exploit['id']}, Name: {exploit['name']}, Type: {exploit['type']}")

    # 2. Launch the example HTTP PoC
    print("\n2. Launching Example HTTP PoC (POC-001):")
    poc_parameters = {
        "target_host": "testphp.vulnweb.com", # Example target
        "target_port": 80
    }
    print(f"Parameters: {poc_parameters}")
    poc_result = exploitx.launch_exploit("POC-001", poc_parameters)
    print("Result:")
    print(f"  Status: {poc_result['status']}")
    print(f"  Success: {poc_result['success']}")
    print(f"  Output:\n{poc_result['output']}")
    if poc_result['error']:
        print(f"  Error: {poc_result['error']}")

    # 3. Show Metasploit Example (without launching, as it requires MSF)
    print("\n3. Showing Metasploit Example Exploit (MSF-EXPLOIT-123):")
    msf_exploit = exploitx.get_exploit_by_id("MSF-EXPLOIT-123")
    if msf_exploit:
        print(f"  Name: {msf_exploit['name']}")
        print(f"  Type: {msf_exploit['type']}")
        print(f"  Module: {msf_exploit['execution'].get('msf_module')}")
        print(f"  Options Template: {msf_exploit['execution'].get('msf_options')}")
        print("  (Note: Launching requires Metasploit Framework installed and configured)")
    else:
        print("  Metasploit example exploit not found.")

    # 4. Add a new exploit definition
    print("\n4. Adding a New Exploit Definition:")
    new_exploit = {
        "id": "CUSTOM-EXPLOIT-01",
        "name": "Custom Service Exploit",
        "description": "Exploits a buffer overflow in a custom service.",
        "type": "poc",
        "target": {
            "service": "custom_service",
            "cve": "CVE-2023-99999"
        },
        "parameters": {
            "target_host": {"type": "string", "required": True},
            "target_port": {"type": "integer", "required": True, "default": 9999},
            "payload": {"type": "string", "required": False, "default": "calc.exe"}
        },
        "execution": {
            "handler": "builtin_custom_exploit" # This handler method needs to be implemented
        }
    }
    exploitx.add_exploit(new_exploit)
    print(f"  Added exploit '{new_exploit['id']}' to the database.")

    # 5. List exploits again to show the new one
    print("\n5. Listing Exploits After Addition:")
    updated_exploits = exploitx.list_exploits()
    for exploit in updated_exploits:
        print(f" - ID: {exploit['id']}, Name: {exploit['name']}")

    print("-" * 30)
    print("ExploitX demo completed.")
